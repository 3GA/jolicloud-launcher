#!/usr/bin/perl

use LWP;
use Logger::Syslog;
use POSIX ":sys_wait_h";

$| = 1;
$0 = "jolicloud-launcher";
info( "starting" );

# kill any remaining jolicloud-launcher from a previous session
opendir(PROC, "/proc");
@cmds = grep { /^\d+$/ && -f "/proc/$_/cmdline" } readdir(PROC);
closedir PROC;

my $killed = 0;
foreach (@cmds) { # jolicloud-launcher
    open(CMD,"/proc/$_/cmdline");
    $cmd = <CMD>;
    close CMD;
    chomp $cmd;
    if ($cmd eq $0 && $$ ne $_) {
        info( "killing $_" );
        kill 'TERM', $_;
        $killed = 1;
    }
}

sleep 1 if $killed;

foreach (@cmds) { # above ought to have killed any remaining jolicloud-daemon or nickel-browser but you never know
    open(CMD,"/proc/$_/cmdline");
    $cmd = <CMD>;
    close CMD;
    chomp $cmd;
    if ($cmd eq "jolicloud-daemon") {
        info( "killing $_" );
        kill 'TERM', $_;
        $killed = 1;
    }
    elsif ($cmd =~ m|^/usr/lib/nickel-browser.*--desktop|) {
        info( "killing $_" );
        kill 'TERM', $_;
        $killed = 1;
    }
}

sleep 1 if $killed;

my $ONLINE_URL = "http://my.jolicloud.com";
my $OFFLINE_URL = "file:///usr/share/jolicloud-daemon/htdocs/index.html";

my $child;

$child = fork;
if ( !defined($child) ) {
    error( "could not fork jolicloud-daemon: $!");
}
elsif ( $child == 0 ) {
    close( STDOUT );
    close( STDERR );
    $0 .= " [jolicloud-daemon]";
    logger_prefix("jolicloud-daemon");
    for ( ;; ) {
        if ( `pgrep -fl ^jolicloud-daemon` ) {
            sleep( 5 );
            next;
        }
        info( "launching" );
        system( "/usr/bin/jolicloud-daemon" );
        if ( $? == -1 ) {
            error( "failed to execute: $!" );
        }
        elsif ( $? & 127 ) {
            error( sprintf( "jolicloud-daemon died with signal %d, %s coredump",
                ( $? & 127 ), ( $? & 128) ? 'with' : 'without' ) );
        }
        else {
            error( "jolicloud-daemon exited with value " . ( $? >> 8 ) );
        }
    }
    exit;
}

$child = fork;
if ( !defined($child) ) {
    error( "could not fork nickel-browser: $!");
}
elsif ( $child == 0 ) {
    my $ua = LWP::UserAgent->new();
    close( STDOUT );
    close( STDERR );
    $0 .= " [nickel-browser]";
    logger_prefix("nickel-browser");

    $max_flag = "--start-maximized";
    open XDPYINFO, "xdpyinfo |";
    while (<XDPYINFO>) {
        if (/^ *dimensions:.+\((\d+)x(\d+) millimeters/) {
            $width = $1*0.03937 ;
            $height = $2*0.03937 ;
            $diag2 = $width*$width + $height*$height;
            if ($diag2 > 169 ) { # 13" diag
                $max_flag = "--no-start-maximized";
            }
        }
    }
    close XDPYINFO;

    for ( ;; ) {
        if ( `pgrep -fl nickel-browser | grep '\\-\\-desktop'` ) {
            sleep( 5 );
            next;
        }

        info( "launching $max_flag" );

        # Do a generic ping of the ping URL. If it responds with error
        # status 400: NOT_LOGGED_IN we know we have internet access to the
        # jolicloud server.
        my $req = HTTP::Request->new( GET => "$ONLINE_URL/api/ping" );
        my $res = $ua->request( $req );
        my $url = $ONLINE_URL;
        unless ( $res->code eq 400 &&
             $res->content eq '{"error":{"code":"NOT_LOGGED_IN"}}' ) {
            # No internet access, display the internal offline URL.
            $url = $OFFLINE_URL;
        }

        system( "/usr/bin/nickel-browser", "--app=$url", "--desktop",
                "--no-default-browser-check",
                $max_flag,
                "--no-first-run", "--enable-ipv6" );
        if ( $? == -1 ) {
            error( "failed to execute: $!" );
        }
        elsif ( $? & 127 ) {
            error( sprintf( "nickel-browser died with signal %d, %s coredump",
                ( $? & 127 ), ( $? & 128) ? 'with' : 'without' ) );
        }
        else {
            error( "nickel-browser exited with value " . ( $? >> 8 ) );
        }
    }
    exit;
}

# If something happens to the main program, kill all the program group

$SIG{ 'INT' } = \&reaper;
$SIG{ 'TERM' } = \&reaper;
$SIG{ 'KILL' } = \&reaper;
$SIG{ 'HUP' } = 'IGNORE';

sub reaper
{
    my $sig = shift;
    info( "caught a SIG$sig--shutting down" );
    kill( 'TERM', -getpgrp );
    exit 0;
}

do { # avoid zombies
    $child = waitpid( -1, 0 );
} while $child > 0;

